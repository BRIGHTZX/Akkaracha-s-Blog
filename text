const {
  currentUser,
  loading,
  error: errorMessage,
} = useSelector((state) => state.user);
const formSchema = z.object({
  username: z.string().min(6, {
    message: "Password must be at least 6 characters.",
  }),
  email: z.string().email({
    message: "Please enter a valid email address.",
  }),
  password: z.string().min(6, {
    message: "Password must be at least 6 characters.",
  }),
});

const form = useForm({
  resolver: zodResolver(formSchema),
  defaultValues: {
    username: currentUser.username,
    email: currentUser.email,
    password: "",
  },
});
const [imageFile, setImageFile] = useState(null);
const [imageFileUrl, setImageFileUrl] = useState(null);
const [imageFileUploadProgress, setImageFileUploadProgress] = useState(null);
const [imageFileUploadError, setImageFileUploadError] = useState(null);
const [imageFileUploading, setImageFileUploading] = useState(false);
const [updateUserSuccess, setUpdateUserSuccess] = useState(null);
const [updateUserError, setUpdateUserError] = useState(null);
const [formData, setFormData] = useState({});
const filePickerRef = useRef();
const dispatch = useDispatch();
const handleImageChange = (e) => {
  const file = e.target.files[0];
  if (file) {
    setImageFile(file);
    setImageFileUrl(URL.createObjectURL(file));
  }
};
useEffect(() => {
  if (imageFile) {
    uploadImage();
  }
}, [imageFile]);

const uploadImage = async () => {
  // service firebase.storage {
  //   match /b/{bucket}/o {
  //     match /{allPaths=**} {
  //       allow read;
  //       allow write: if
  //       request.resource.size < 2 * 1024 * 1024 &&
  //       request.resource.contentType.matches('image/.*')
  //     }
  //   }
  // }
  setImageFileUploading(true);
  setImageFileUploadError(null);
  const storage = getStorage(app);
  const fileName = new Date().getTime() + imageFile.name;
  const storageRef = ref(storage, fileName);
  const uploadTask = uploadBytesResumable(storageRef, imageFile);
  uploadTask.on(
    "state_changed",
    (snapshot) => {
      const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;

      setImageFileUploadProgress(progress.toFixed(0));
    },
    (error) => {
      setImageFileUploadError(
        "Could not upload image (File must be less than 2MB)"
      );
      setImageFileUploadProgress(null);
      setImageFile(null);
      setImageFileUrl(null);
      setImageFileUploading(false);
    },
    () => {
      getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {
        setImageFileUrl(downloadURL);
        setFormData({ ...formData, profilePicture: downloadURL });
        setImageFileUploading(false);
      });
    }
  );
};

const handleChange = (e) => {
  setFormData({ ...formData, [e.target.id]: e.target.value });
};

const handleSubmit = async (e) => {
  e.preventDefault();
  setUpdateUserError(null);
  setUpdateUserSuccess(null);
  if (Object.keys(formData).length === 0) {
    setUpdateUserError("No changes made");
    return;
  }
  if (imageFileUploading) {
    setUpdateUserError("Please wait for image to upload");
    return;
  }
  try {
    dispatch(updateStart());
    const res = await fetch(`/api/user/update/${currentUser._id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formData),
    });
    const data = await res.json();
    if (!res.ok) {
      dispatch(updateFailure(data.message));
      setUpdateUserError(data.message);
    } else {
      dispatch(updateSuccess(data));
      setUpdateUserSuccess("User's profile updated successfully");
    }
  } catch (error) {
    dispatch(updateFailure(error.message));
    setUpdateUserError(error.message);
  }
};
